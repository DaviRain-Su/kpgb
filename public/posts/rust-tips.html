<!DOCTYPE html> <html lang="zh-CN"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>About Rust tips - Anonymous IPFS Blog</title>  <meta name="title" content="About Rust tips - Anonymous IPFS Blog"> <meta name="description" content="在 Rust 中，如果你想为你的 中的类型编写带有可选的 的测试，你可以使用 属性和 属性来做到这一点。 以下是一个例子： 在这个例子中， 只有在 被启用时才会被定义，同样， 测试也只有在 被启用时才会被运行。 要运行这个测试，你需要使用以下命令，其中 是你的 的名字： 这个命令会启用 特性并运行所有的测试，包括依赖于…"> <meta name="keywords" content="IPFS, blog, decentralized, Anonymous"> <meta name="author" content="DaviRain"> <meta name="robots" content="index, follow"> <meta name="language" content="Chinese">  <meta property="og:type" content="article"> <meta property="og:url" content="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/posts/rust-tips.html"> <meta property="og:title" content="About Rust tips - Anonymous IPFS Blog"> <meta property="og:description" content="在 Rust 中，如果你想为你的 中的类型编写带有可选的 的测试，你可以使用 属性和 属性来做到这一点。 以下是一个例子： 在这个例子中， 只有在 被启用时才会被定义，同样， 测试也只有在 被启用时才会被运行。 要运行这个测试，你需要使用以下命令，其中 是你的 的名字： 这个命令会启用 特性并运行所有的测试，包括依赖于…"> <meta property="og:image" content="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/images/og-default.svg"> <meta property="og:site_name" content="Anonymous IPFS Blog"> <meta property="article:published_time" content="2025-07-23T00:49:44+0000"> <meta property="article:modified_time" content="2025-07-23T00:49:45+0000"> <meta property="article:author" content="DaviRain">  <meta property="twitter:card" content="summary_large_image"> <meta property="twitter:url" content="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/posts/rust-tips.html"> <meta property="twitter:title" content="About Rust tips - Anonymous IPFS Blog"> <meta property="twitter:description" content="在 Rust 中，如果你想为你的 中的类型编写带有可选的 的测试，你可以使用 属性和 属性来做到这一点。 以下是一个例子： 在这个例子中， 只有在 被启用时才会被定义，同样， 测试也只有在 被启用时才会被运行。 要运行这个测试，你需要使用以下命令，其中 是你的 的名字： 这个命令会启用 特性并运行所有的测试，包括依赖于…"> <meta property="twitter:image" content="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/images/twitter-card.svg">  <link rel="canonical" href="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/posts/rust-tips.html">  <link rel="icon" type="image/svg+xml" href="&#x2F;kpgb/favicon.svg"> <link rel="alternate icon" href="&#x2F;kpgb/favicon.ico"> <link rel="manifest" href="&#x2F;kpgb/site.webmanifest">  <link rel="stylesheet" href="&#x2F;kpgb/css/style.css">  <link rel="alternate" type="application/rss+xml" title="Anonymous IPFS Blog RSS Feed" href="&#x2F;kpgb/feed.xml">  <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "About Rust tips",
        "description": "在 Rust 中，如果你想为你的 中的类型编写带有可选的 的测试，你可以使用 属性和 属性来做到这一点。 以下是一个例子： 在这个例子中， 只有在 被启用时才会被定义，同样， 测试也只有在 被启用时才会被运行。 要运行这个测试，你需要使用以下命令，其中 是你的 的名字： 这个命令会启用 特性并运行所有的测试，包括依赖于这个特性的测试。 要将 转换为 ，可以使用 中的 方法。下面是一个示例实现： 在这里，我们使用 将 转换为迭代器。然后调用 ，传入一个初始值 和一个闭包，该闭包接受两个参数：一个累加器（ ）和一个 。...",
        "author": {
            "@type": "Person",
            "name": "DaviRain"
        },
        "datePublished": "2025-07-23T00:49:44+0000",
        "dateModified": "2025-07-23T00:49:45+0000",
        "publisher": {
            "@type": "Organization",
            "name": "Anonymous IPFS Blog",
            "logo": {
                "@type": "ImageObject",
                "url": "https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/images/logo.svg"
            }
        },
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/posts/rust-tips.html"
        },
        "wordCount": "351",
        "keywords": "",
        
        "articleSection": "Tech",
        
        "inLanguage": "zh-CN"
    }
    </script>
    
</head>
<body>
    <header>
        <nav>
            <div class="container">
                <h1><a href="&#x2F;kpgb/">Anonymous IPFS Blog</a></h1>
                <ul>
                    <li><a href="&#x2F;kpgb/">Home</a></li>
                    <li><a href="&#x2F;kpgb/archive">Archive</a></li>
                    <li><a href="&#x2F;kpgb/tags">Tags</a></li>
                    <li><a href="&#x2F;kpgb/docs">Docs</a></li>
                    <li><a href="&#x2F;kpgb/feed.xml">RSS</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main>
        <div class="container">
            
<article class="post">
    <header>
        <h1>About Rust tips</h1>
        <div class="post-meta">
            <span class="author">By DaviRain</span>
            <span class="date">2025-07-23 00:49</span>
            
            <span class="reading-time">⏱️ 7 min read</span>
            
            
            <span class="category">Tech</span>
            
        </div>
        
    </header>

    
    <div class="post-with-toc">
        <aside class="toc-container">
            <nav class="toc" id="toc">
    <h2 class="toc-title">Table of Contents</h2>
    <ul class="toc-list"><li class="toc-item toc-level-2">
                <a href="#在rust中如何为本crates中的类型带有可选的feature编写测试" class="toc-link">在rust中如何为本crates中的类型带有可选的feature编写测试</a></li><li class="toc-item toc-level-2">
                <a href="#将-vec_result_-e_-转换为-result_vec_-e_" class="toc-link">将 Vec&lt;Result, E&gt; 转换为 Result&lt;Vec, E&gt;</a></li><li class="toc-item toc-level-2">
                <a href="#rust十进制和16进制之间的互相转换" class="toc-link">Rust十进制和16进制之间的互相转换</a></li><li class="toc-item toc-level-2">
                <a href="#and-then-和-map在使用上有什么区别" class="toc-link">and_then 和 map在使用上有什么区别</a></li></ul></nav>
        </aside>
        <div class="post-content">
            <h2 id="在rust中如何为本crates中的类型带有可选的feature编写测试">在rust中如何为本crates中的类型带有可选的feature编写测试</h2>
<p>在 Rust 中，如果你想为你的 <code>crate</code> 中的类型编写带有可选的 <code>feature</code> 的测试，你可以使用<code>cfg_attr</code>属性和<code>#[cfg(feature = "feature_name")]</code>属性来做到这一点。</p>
<p>以下是一个例子：</p>
<pre><code class="language-rust">// 在lib.rs或者main.rs中
#[cfg(feature = "feature_name")]
pub struct MyStruct {
    // ...
}

#[cfg(test)]
mod tests {
    #[test]
    #[cfg(feature = "feature_name")]
    fn test_my_struct() {
        // 在这里写你的测试
    }
}
</code></pre>
<p>在这个例子中，<code>MyStruct</code>只有在<code>feature_name</code>被启用时才会被定义，同样，<code>test_my_struct</code>测试也只有在<code>feature_name</code>被启用时才会被运行。</p>
<p>要运行这个测试，你需要使用以下命令，其中<code>my_crate</code>是你的 <code>crate</code> 的名字：</p>
<pre><code class="language-bash">cargo test --features feature_name
</code></pre>
<p>这个命令会启用<code>feature_name</code>特性并运行所有的测试，包括依赖于这个特性的测试。</p>
<h2 id="将-vec_lt_result_-e_gt_-转换为-result_lt_vec_-e_gt_">将 Vec&lt;Result<T>, E&gt; 转换为 Result&lt;Vec<T>, E&gt;</h2>
<p>要将 <code>Vec&lt;Result&lt;T, E&gt;&gt;</code> 转换为 <code>Result&lt;Vec, E&gt;</code>，可以使用 <code>Iterator trait</code> 中的 <code>try_fold ()</code> 方法。下面是一个示例实现：</p>
<p>在这里，我们使用 <code>into_iter ()</code> 将 <code>Vec</code> 转换为迭代器。然后调用 <code>try_fold ()</code>，传入一个初始值 <code>Vec::new ()</code> 和一个闭包，该闭包接受两个参数：一个累加器（<code>acc</code>）和一个 <code>Result（res）</code>。</p>
<pre><code class="language-rust">fn vec_result_to_result_vec&lt;T, E&gt;(v: Vec&lt;Result&lt;T, E&gt;&gt;) -&gt; Result&lt;Vec&lt;T&gt;, E&gt; {
    v.into_iter().try_fold(Vec::new(), |mut acc, res| {
        match res {
            Ok(t) =&gt; {
                acc.push(t);
                Ok(acc)
            },
            Err(e) =&gt; Err(e)
        }
    })
}
</code></pre>
<p>闭包模式匹配 <code>Result</code> 变体，将 <code>Ok</code> 值推入 <code>acc</code> 向量并返回 <code>Ok (acc)</code>，如果 <code>Result</code> 是 <code>Err</code>，则返回 <code>Err (e)</code>。<code>try_fold ()</code> 方法将继续迭代迭代器中的剩余项，并将更新后的累加器值传递给每个后续调用闭包的调用。</p>
<p>如果原始 <code>Vec</code> 中的任何 <code>Result</code> 是 <code>Err</code>，则 <code>try_fold ()</code> 将短路并返回遇到的第一个 <code>Err</code>。否则，它将返回带有解包的 <code>T</code> 值的 <code>Vec</code> 的 <code>Ok (acc)</code>。</p>
<h2 id="rust十进制和16进制之间的互相转换">Rust十进制和16进制之间的互相转换</h2>
<p>在 Rust 中，可以使用 <code>format!()</code> 宏将十进制数格式化为十六进制字符串。下面是一个简单的示例实现：</p>
<pre><code class="language-rust">fn decimal_to_hex(decimal: u32) -&gt; String {
    format!("{:X}", decimal)
}
</code></pre>
<p>这里使用了 <code>{}</code> 格式化字符串，它将无符号十进制数转换为大写十六进制字符串。例如，将数字 123456789 转换为十六进制字符串，可以这样调用函数：</p>
<pre><code class="language-rust">let hex_string = decimal_to_hex(123456789);
println!("{}", hex_string); // 输出: "75BCD15"
</code></pre>
<p>注意，如果要处理更大的数字，可以使用 u64 或 u128 类型。如果需要将十六进制字符串转换回十进制数字，则可以使用 <code>u64::from_str_radix ()</code> 函数。</p>
<h2 id="and-then-和-map在使用上有什么区别">and_then 和 map在使用上有什么区别</h2>
<p>在 Rust 中，and_then 和 map 都是用于在对 Option 或 Result 进行转换时使用的方法，但它们的使用方式有所不同。</p>
<p>map 方法将一个 Option或 Result&lt;T, E&gt; 映射到一个新的 Option或 Result&lt;U, E&gt;，其中函数闭包中的操作是应用于 Option 或 Result 中包含的值的。如果原始值是 None 或 Err，则映射函数将不会被执行，而是直接返回一个新的 None 或 Err。</p>
<p>例如，下面是使用 map 方法将 Option中的值加倍的示例：</p>
<p>and_then 方法在使用上与 map 类似，但是，它的返回值类型是 Option或 Result&lt;U, E&gt; 而不是 U。在 and_then 的闭包中，我们必须返回一个新的 Option 或 Result，而不是直接返回一个值。这意味着 and_then 可用于将一个 Option 或 Result 转换成另一个 Option 或 Result，同时也可以进行一些逻辑测试。</p>
<pre><code class="language-rust">let some_number = Some(5);
let doubled = some_number.map(|x| x * 2);
assert_eq!(doubled, Some(10));
</code></pre>
<p>例如，下面是一个使用 and_then 方法将 Option中的值乘以 3 的示例，如果该值小于 10，则返回 None：</p>
<p>在上面的示例中，我们在 and_then 的闭包中测试了 some_number 是否小于 10。如果是，则返回 None，否则返回 Some (x * 3)，其中 x 是原始 Option中的值。在第一个示例中，some_number 的值为 5，因此，闭包返回 None，导致整个表达式返回 None。在第二个示例中，some_number 的值为 11，因此，闭包返回 Some (33)，导致整个表达式返回 Some (33)。</p>
<pre><code class="language-rust">let some_number = Some(5);
let result = some_number.and_then(|x| {
    if x &lt; 10 {
        None
    } else {
        Some(x * 3)
    }
});
assert_eq!(result, None);

let some_number = Some(11);
let result = some_number.and_then(|x| {
    if x &lt; 10 {
        None
    } else {
        Some(x * 3)
    }
});
assert_eq!(result, Some(33));
</code></pre>
<p>因此，在使用时，map 用于简单的值转换，而 and_then 用于更复杂的操作和逻辑测试。</p>

        </div>
    </div>
    

    <footer class="post-footer">
        <div class="post-info">
            <p><strong>Storage ID:</strong> <code>QmeC1JrFWMsqZkixtS8SAmiZ52W6U2K9Pf8NNKnkLbWoX7</code></p>
            
            <p><strong>IPFS Link:</strong> <a href="https:&#x2F;&#x2F;ipfs.io&#x2F;ipfs&#x2F;QmeC1JrFWMsqZkixtS8SAmiZ52W6U2K9Pf8NNKnkLbWoX7" target="_blank">View on IPFS</a></p>
            
            <p><strong>Content Hash:</strong> <code>81f971a9b2a8f7fa86358a327ef5efc97e6cd636010b55f1bc1fbe6777b94154</code></p>
        </div>
        <nav class="post-nav">
            <a href="/archive.html">← Back to Archive</a>
        </nav>
    </footer>

    
    
    <section class="related-posts">
        <h2>Related Posts</h2>
        <div class="related-posts-grid">
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;chanzhe.html">禅者的初心📒</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">1 min read</span>
                    
                </div>
                
                    <p class="excerpt">是智慧在追寻智慧。 初学者的心是开放的，而行家的心是收紧的。 我们的本心内含万物，它本自具足。 如果你的心是空的，它可以随时接受任何事物；它向所有的事物开放。初学者的心是开放的，而行家的心是收紧的。 分别心太重，是自我束缚。太过苛刻和贪婪，你的心便不会丰饶富足。而失去了本自具足的心，我们会失守所有的…</p>
                
                
            </article>
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;T.html">TingHu语录📒</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">4 min read</span>
                    
                </div>
                
                    <p class="excerpt">大多数人最后跑不赢比特币这句话我都不知道讲了多少次了(实际上最后很多人还亏钱)。 如果你指望我通过推荐你买小山寨跑赢比特币，那还是别关注我了，我没有办法给出我认为合理的建议。 现在说也许还早，但是大家可以记住这一条，年底筛选投资标的的时候， 2019-2021这轮牛市表现一般的老币，全部不作为目标，…</p>
                
                
            </article>
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;rust-raw-pointer.html">About Rust Raw Pointer</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">2 min read</span>
                    
                </div>
                
                    <p class="excerpt">在Rust中可以使用原生指针，原生指针是一种裸指针，不受Rust的安全性检查限制。 原生指针有两种类型： 和 ，分别是不可变和可变的原生指针。 Rust提供了一个函数可以获取类型的大小： 。 这里提供了一个简单的例子，展示了如何使用原生指针。 原生指针是一种裸指针，不受Rust的安全性检查限制，可以…</p>
                
                
            </article>
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;learn-ocaml-sources.html">学习Ocaml的资源</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">1 min read</span>
                    
                </div>
                
                    <p class="excerpt">Introduction to Objective Ocaml Objective Caml 简介。 OCaml from the Very Beginning 一本非常温和的教科书，推荐用于本课程。本书的 PDF 和 HTML 格式都是免费的。 A guided tour [ of OCaml ]…</p>
                
                
            </article>
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;rust-sources.html">Rust Resources Every Learner Should Know in 2023</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">12 min read</span>
                    
                </div>
                
                    <p class="excerpt">去年，我开始学习Rust，主要是为了应用于嵌入式系统。当时，我也在一篇名为“ 35个Rust学习资源，每个初学者在2022年都应该知道 ”的帖子中分享了我所遇到的所有学习材料。自那时以来，我并没有停止学习 Rust，而是不断努力巩固自己的基础。因此，我一直在寻找新的学习资源。 在本文中，我将通过添加…</p>
                
                
            </article>
            
        </div>
    </section>
    

    
    
    <div class="comments">
        <h2>Comments</h2>
        <script src="https://giscus.app/client.js"
                data-repo="davirain-su&#x2F;kpgb"
                data-repo-id="R_kgDOPP4-yg"
                data-category="General"
                data-category-id="DIC_kwDOPP4-ys4CtTKw"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="preferred_color_scheme"
                data-lang="zh-CN"
                data-loading="lazy"
                crossorigin="anonymous"
                async>
        </script>
    </div>
    
</article>


<script>
// TOC active section highlighting
(function() {
    const tocLinks = document.querySelectorAll('.toc-link');
    const headings = document.querySelectorAll('.post-content h1[id], .post-content h2[id], .post-content h3[id], .post-content h4[id], .post-content h5[id], .post-content h6[id]');
    
    if (tocLinks.length === 0 || headings.length === 0) return;
    
    function updateActiveSection() {
        const scrollPosition = window.scrollY + 100; // Offset for better UX
        
        let activeHeading = null;
        for (const heading of headings) {
            if (heading.offsetTop <= scrollPosition) {
                activeHeading = heading;
            } else {
                break;
            }
        }
        
        if (activeHeading) {
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + activeHeading.id) {
                    link.classList.add('active');
                }
            });
        }
    }
    
    // Update on scroll
    let scrollTimer;
    window.addEventListener('scroll', () => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(updateActiveSection, 50);
    });
    
    // Initial update
    updateActiveSection();
})();
</script>


        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 Anonymous. Powered by IPFS & KPGB.</p>
            <p>A decentralized blog powered by IPFS</p>
        </div>
    </footer>
</body>
</html>