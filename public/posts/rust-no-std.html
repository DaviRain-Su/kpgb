<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust no-std - Anonymous IPFS Blog</title>
    <meta name="description" content="A decentralized blog powered by IPFS">
    <link rel="stylesheet" href="&#x2F;kpgb/css/style.css">
    <link rel="alternate" type="application/rss+xml" title="Anonymous IPFS Blog RSS Feed" href="&#x2F;kpgb/feed.xml">
</head>
<body>
    <header>
        <nav>
            <div class="container">
                <h1><a href="&#x2F;kpgb/">Anonymous IPFS Blog</a></h1>
                <ul>
                    <li><a href="&#x2F;kpgb/">Home</a></li>
                    <li><a href="&#x2F;kpgb/archive">Archive</a></li>
                    <li><a href="&#x2F;kpgb/tags">Tags</a></li>
                    <li><a href="&#x2F;kpgb/docs">Docs</a></li>
                    <li><a href="&#x2F;kpgb/feed.xml">RSS</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main>
        <div class="container">
            
<article class="post">
    <header>
        <h1>Rust no-std</h1>
        <div class="post-meta">
            <span class="author">By DaviRain</span>
            <span class="date">2025-07-23 00:49</span>
            
            <span class="category">Tech</span>
            
        </div>
        
    </header>

    <div class="post-content">
        <p>改写 std 的库为支持 no_std 的库及写出一个支持 std 和 no_std 库的经验谈 <a href="https://github.com/DaviRain-Su/rust-no-std-source">github repo</a>。</p>
<h2>简介</h2>
<p>首先介绍 std 和 no_std 的区别，然后介绍使用 no_std 库的方式，由于支持 no_std 的特性有两种不同的方式，因此使用 no_std 库也有两种方式。其次，验证一个库是否支持 no_std 特性的验证方式，如何改写一个 std 的库为同时支持 std 和 no_std 的特性方法。具体的如何写一个支持 std 和 no_std 的库。一些在 std 和 no_std 下都可以使用的 primitive 的仓库和相关的资源和文章。</p>
<h2>目录</h2>
<ul>
<li>std 和 no_std 的区别</li>
<li>Rust 中使用 no_std 的两种方式</li>
<li>验证一个库是否支持 no_std 特性的验证方式</li>
<li>具体的写一个支持 std 和 no_std 的库</li>
<li>一些 no_std 和 std 可以使用 primitive 类型的仓库和相关资源的文章</li>
</ul>
<h2>std 和 no_std 的区别</h2>
<h3>核心库</h3>
<p>Rust 语言的语法由核心库和标准库共同提供。 其中 Rust 核心库是标准库的基础。核心库中定义的是 Rust 语言的核心，不依赖于操作系统和网络等相关的库，甚至不知道堆分配，也不提供并发和 I/O</p>
<p>可以通过在模块顶部引入 #![no_std] 来使用核心库。核心库和标准库的功能有一些重复，包括如下部分：</p>
<ul>
<li>基础的 trait，如 Copy、Debug、Display、Option 等。</li>
<li>基本原始类型，如 bool、char、i8/u8、i16/u16、i32/u32、i64/u64、isize/usize、f32/f64、str、array、slice、tuple、pointer 等。</li>
<li>常用功能型数据类型，满足常见的功能性需求，如 String、Vec、HashMap、Rc、Arc、Box 等。</li>
<li>常用的宏定义，如 println！、assert！、panic！、vec！等。做嵌入式应用开发的时候，核心库是必需的。</li>
</ul>
<h3>标准库</h3>
<p>Rust 标准库提供应用程序开发所需要的基础和跨平台支持。标准库包含的内容大概如下：</p>
<ul>
<li>与核心库一样的基本 trait、原始数据类型、功能型数据类型和常用宏等，以及与核心库几乎完全一致的 API。</li>
<li>并发、I/O 和运行时。例如线程模块、用于消息传递的通道类型、Sync trait - 等并发模块，文件、TCP、UDP、管道、套接字等常见 I/O。</li>
<li>平台抽象。os 模块提供了许多与操作环境交互的基本功能，包括程序参数、环境变量和目录导航；路径模块封装了处理文件路径的平台特定规则。</li>
<li>底层操作接口，比如 std：：mem、std：：ptr、std：：intrinsics 等，操作内存、指针、调用编译器固有函数。</li>
<li>可选和错误处理类型 Option 和 Result，以及各种迭代器等。</li>
</ul>
<p>还有一些解释，#![no_std] 是一个 crate level 级别的属性，表示 core crate 将链接到 core crate 而不是 std crate。</p>
<p>下面是 std crate 和 core crate 的解释，其实这里也就解释了标准库与和核心库之间的区别。当让也内在的包括了 std 与 no_std 之间的区别。</p>
<p>首先是，std crate 是 Rust 的标准库。它包含的功能假定程序将在操作系统上运行，而不是直接在裸系统上运行。std 还假定操作系统是一个通用的操作系统，就像人们在服务器和台式机上看到的那样。出于这个原因，std 为通常在这类操作系统中发现的功能提供了一个标准的 API: 线程、文件、套接字、文件系统、进程等等。</p>
<p>然后是，core crate 是 std crate 的一个子集，对程序运行的系统不做任何假设。因此它提供了基于语言的 API，如浮点，字符串和切片，以及暴露处理器特性的 API，如原子操作和 SIMD 指令。然而，它缺乏涉及堆内存分配和 I/O 的任何 API。</p>
<p>对于一个应用程序来说，std 所做的不仅仅是提供一种访问操作系统抽象的方式，std 还负责涉及堆栈溢出保护，处理命令行参数，以及在程序的主函数被调用之前生成主线程。一个#![no_std]应用程序缺乏所有这些标准的运行时，所以它必须初始化自己的运行时，如果需要的话。</p>
<p>由于这些特性，#![no_std]应用程序可以是第一个或者唯一在系统上运行的代码。</p>
<h2>Rust 中 no_std 的一些使用方法</h2>
<p>主要具体介绍第二种方式的使用 no_std</p>
<p>具体如何使用，参见写一个 no_std 的库的第二种使用方式。</p>
<p>也可参考，实例:<a href="https://serde.rs/no-std.html">serde no-std 的使用规范</a></p>
<h2>验证一个库是否支持 no_std 的验证方式</h2>
<pre><code class="language-bash">cargo check --target wasm32-unknown-unknown
</code></pre>
<p>但是 wasm 环境不一定就是 no_std，或者别的编译目标也可以，也就是裸露的编译目标环境不带有任何系统的环境。</p>
<p>参考文档: <a href="https://zhuanlan.zhihu.com/p/53064186">使用 Rust 编写操作系统（一）：独立式可执行程序</a></p>
<p>具体的写一个 no_std 的库#
创建一个 no_std 库的第一种方式（使用#![no_std])</p>
<p>使用#![no_std]的话，默认的就是这个库是在 no_std 环境下的，然而又因为 no_std 下的库 一般来说都是核心库，而核心库又是标准库的子集，所以声明 #![no_std] 写出来的库，也可以在 std（标准库环境）下使用。</p>
<ul>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/cd90f28855cfe794c235976bb58c1c5ecb8c7fa9">创建一个仓库</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/cd90f28855cfe794c235976bb58c1c5ecb8c7fa9">使用 #![no_std] 将这个仓库中的函数能支持在 no_std 和 std 下使用</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/8bcd0b909ee116d3dc9c6464c2548e1c008d672e">开始添加一个函数编译报错 commit 1</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/ae94f9cf147b7ce37632cb4e9c36e20c5135b3ad">修复错误 commit 2</a></li>
</ul>
<h2>创建 no_std 库的第二种方式（使用 #![cfg_attr (not (features = “std”), no_std)] )#</h2>
<ul>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/8cfd063be536028d9f8cfe1c7c04f16765825f8c">创建一个仓库</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/aa09b0d2e2807d788564aea5fa4fc8cbfc760043">使用#![cfg_attr(not(feature = “std”), no_std)]</a></li>
<li><a href="https://github.com/DaviRain-Su/rust-no-std-source/commit/aa09b0d2e2807d788564aea5fa4fc8cbfc760043">添加的一些函数和测试</a></li>
</ul>
<p>使一些不能在 no_std 环境下运行的仓库也能在 no_std 下支持</p>
<p>首先，要验证这个库能不能支持 no_std 的环境（见，验证一个库是否支持 no_std 的验证方式）。</p>
<p>找出这个库依赖的库支持 no_std 的方式，如果使用的是#![no_std] 那么这个库本身就是可以在 std 和 no_std 下同时的运行。</p>
<p>如果使用的是<code>#![cfg_attr(not(features = "std"), no_std)]</code>, 就需要打开<code>default-features = false</code>, 进行配置。</p>
<p>最后可能需要做一些标准库的替换，使其能在 no_std 和 std 同时编译成功，一些可以使用的类型库有 sp-std (这个库仅仅封装了一部分的类型，例如有些类型是没有的，string,File, IO) 当然，IO,File，这些标准库在核心库当中是没有的。还有 rust 本身的 alloc, core 这些都是属于核心库的。也是在 no_std 环境下支持的。</p>
<p>具体的使用案例:</p>
<ul>
<li><a href="https://github.com/cosmos/ics23/pull/41">相关的 Pr, 使 ics23 支持 no_std</a></li>
</ul>
<p><a href="https://github.com/cosmos/ics23/pull/41/commits/dac5c3d0fc368e0b92c4a4804b6787bd1c3fb168">有些代码也在 no_std 写测试很难。因为这里做了编译选择处理</a></p>
<h2>一些 no_std 和 std 可以使用的 primitive 类型的仓库</h2>
<ul>
<li><a href="https://github.com/paritytech/substrate/tree/master/primitives/std">sp-std</a></li>
<li><a href="https://doc.rust-lang.org/alloc/index.html">rust Alloc crate</a></li>
<li><a href="https://doc.rust-lang.org/core/index.html">rust Core crate</a></li>
</ul>
<h2>引用及资源</h2>
<ul>
<li><a href="https://weread.qq.com/web/reader/0303203071848774030b9d6k9bf32f301f9bf31c7ff0a60">Rust 编程之道核心库和标准库的介绍</a></li>
<li><a href="https://docs.rust-embedded.org/book/intro/hardware.html">Rust embeded book</a></li>
<li><a href="https://users.rust-lang.org/t/best-practice-of-extending-a-no-std-crate/12281/5">扩展 no_std crate 的最佳实践</a></li>
<li><a href="https://github.com/rust-lang/api-guidelines">Rust API guidelines</a></li>
<li><a href="https://rust-lang.github.io/api-guidelines/naming.html#c-feature">Rust API guidelines Nameing</a></li>
<li><a href="https://serde.rs/no-std.html">serde no_std 的使用规范</a></li>
<li><a href="https://github.com/rust-embedded/awesome-embedded-rust#no-std-crates">awesome-embedded-rust#no-std-crates</a></li>
<li><a href="https://crates.io/categories/no-std">no standard library</a></li>
<li><a href="https://github.com/serde-rs/serde/blob/master/serde/src/lib.rs#L113-L193">serde 使用的第二种方式</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1184-stabilize-no_std.html">Rust RFC Book no_std</a></li>
<li><a href="https://justjjy.com/Rust-no-std">Rust no_std DAQ</a></li>
<li><a href="https://blog.dbrgn.ch/2019/12/24/testing-for-no-std-compatibility/">testing-for-no-std-compatibility</a></li>
<li><a href="https://docs.substrate.io/">substrate 中关于 cfg_attr 的介绍</a></li>
</ul>
<h2>结论</h2>
<p>参照 <code>serder</code> 的使用以及一些论坛的讨论，推荐使用<code>#![cfg_attr(not(feature = "std"), no_std ))]</code>来同时支持 <code>std</code> 和 <code>no_std</code>。</p>

    </div>

    <footer class="post-footer">
        <div class="post-info">
            <p><strong>Storage ID:</strong> <code>QmPL5UgmuZMs3jH7RgkApzwh5F65ydW437qDv8rt9X72w4</code></p>
            
            <p><strong>IPFS Link:</strong> <a href="https:&#x2F;&#x2F;ipfs.io&#x2F;ipfs&#x2F;QmPL5UgmuZMs3jH7RgkApzwh5F65ydW437qDv8rt9X72w4" target="_blank">View on IPFS</a></p>
            
            <p><strong>Content Hash:</strong> <code>32894a5eb4b4e24b09b7c8ebcc938b24dbbce8d3bbf3752ea680baa5772ba2b6</code></p>
        </div>
        <nav class="post-nav">
            <a href="/archive.html">← Back to Archive</a>
        </nav>
    </footer>
</article>

        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 Anonymous. Powered by IPFS & KPGB.</p>
            <p>A decentralized blog powered by IPFS</p>
        </div>
    </footer>
</body>
</html>