<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Fork and Upstreams ：如何去做一个很酷的技巧 - Anonymous IPFS Blog</title>
    
    <!-- Primary Meta Tags -->
    <meta name="title" content="Git Fork and Upstreams ：如何去做一个很酷的技巧 - Anonymous IPFS Blog">
    <meta name="description" content="Fork 项目来进行自己的修改，可以让你轻松地整合自己的贡献，但是如果你没有将这些修改发回上游 - 也就是发回父亲仓库 -- 你就有可能失去对他们的跟踪，这可能会导致你的版本库中出现不同的线路。为了确保所有贡献者都从同有个地方获取信息，你需要了解一些关于 git forking 与 git upstream 如何交互的…">
    <meta name="keywords" content="IPFS, blog, decentralized, Anonymous">
    <meta name="author" content="DaviRain">
    <meta name="robots" content="index, follow">
    <meta name="language" content="Chinese">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/posts/git-frok.html">
    <meta property="og:title" content="Git Fork and Upstreams ：如何去做一个很酷的技巧 - Anonymous IPFS Blog">
    <meta property="og:description" content="Fork 项目来进行自己的修改，可以让你轻松地整合自己的贡献，但是如果你没有将这些修改发回上游 - 也就是发回父亲仓库 -- 你就有可能失去对他们的跟踪，这可能会导致你的版本库中出现不同的线路。为了确保所有贡献者都从同有个地方获取信息，你需要了解一些关于 git forking 与 git upstream 如何交互的…">
    <meta property="og:image" content="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/images/og-default.svg">
    <meta property="og:site_name" content="Anonymous IPFS Blog">
    
    <meta property="article:published_time" content="2025-07-23T00:49:35+0000">
    <meta property="article:modified_time" content="2025-07-23T00:49:35+0000">
    <meta property="article:author" content="DaviRain">
    
    
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/posts/git-frok.html">
    <meta property="twitter:title" content="Git Fork and Upstreams ：如何去做一个很酷的技巧 - Anonymous IPFS Blog">
    <meta property="twitter:description" content="Fork 项目来进行自己的修改，可以让你轻松地整合自己的贡献，但是如果你没有将这些修改发回上游 - 也就是发回父亲仓库 -- 你就有可能失去对他们的跟踪，这可能会导致你的版本库中出现不同的线路。为了确保所有贡献者都从同有个地方获取信息，你需要了解一些关于 git forking 与 git upstream 如何交互的…">
    <meta property="twitter:image" content="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/images/twitter-card.svg">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/posts/git-frok.html">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="&#x2F;kpgb/favicon.svg">
    <link rel="alternate icon" href="&#x2F;kpgb/favicon.ico">
    <link rel="manifest" href="&#x2F;kpgb/site.webmanifest">
    
    <!-- CSS -->
    <link rel="stylesheet" href="&#x2F;kpgb/css/style.css">
    
    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="Anonymous IPFS Blog RSS Feed" href="&#x2F;kpgb/feed.xml">
    
    <!-- JSON-LD Structured Data -->
    
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "Git Fork and Upstreams ：如何去做一个很酷的技巧",
        "description": "Fork 项目来进行自己的修改，可以让你轻松地整合自己的贡献，但是如果你没有将这些修改发回上游 - 也就是发回父亲仓库 -- 你就有可能失去对他们的跟踪，这可能会导致你的版本库中出现不同的线路。为了确保所有贡献者都从同有个地方获取信息，你需要了解一些关于 git forking 与 git upstream 如何交互的原理。在这篇博客中，我将向你介绍基础知识，疑难杂症，甚至给你留下一个很酷的小技巧，让你走在曲线的前面。 让我先详细介绍一下与上游仓库交互的常见设置和最基本的工作流程。 在一个标准的设置中，你通常有一个 origin 和一个 upstream remote - 后者是项目的守门人，或者你希望贡献的真实来源。 首先，缺人你已经为上游仓库设置了一个 remote, 并希望也设置了一个 origin: 如果你没有上游，你可以很容易地用远程命令添加它。...",
        "author": {
            "@type": "Person",
            "name": "DaviRain"
        },
        "datePublished": "2025-07-23T00:49:35+0000",
        "dateModified": "2025-07-23T00:49:35+0000",
        "publisher": {
            "@type": "Organization",
            "name": "Anonymous IPFS Blog",
            "logo": {
                "@type": "ImageObject",
                "url": "https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/images/logo.svg"
            }
        },
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:&#x2F;&#x2F;Anonymous.github.io&#x2F;kpgb/posts/git-frok.html"
        },
        "wordCount": "299",
        "keywords": "",
        
        "articleSection": "Tech",
        
        "inLanguage": "zh-CN"
    }
    </script>
    
</head>
<body>
    <header>
        <nav>
            <div class="container">
                <h1><a href="&#x2F;kpgb/">Anonymous IPFS Blog</a></h1>
                <ul>
                    <li><a href="&#x2F;kpgb/">Home</a></li>
                    <li><a href="&#x2F;kpgb/archive">Archive</a></li>
                    <li><a href="&#x2F;kpgb/tags">Tags</a></li>
                    <li><a href="&#x2F;kpgb/docs">Docs</a></li>
                    <li><a href="&#x2F;kpgb/feed.xml">RSS</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main>
        <div class="container">
            
<article class="post">
    <header>
        <h1>Git Fork and Upstreams ：如何去做一个很酷的技巧</h1>
        <div class="post-meta">
            <span class="author">By DaviRain</span>
            <span class="date">2025-07-23 00:49</span>
            
            <span class="reading-time">⏱️ 12 min read</span>
            
            
            <span class="category">Tech</span>
            
        </div>
        
    </header>

    
    <div class="post-with-toc">
        <aside class="toc-container">
            <nav class="toc" id="toc">
    <h2 class="toc-title">Table of Contents</h2>
    <ul class="toc-list"><li class="toc-item toc-level-2">
                <a href="#git-upstream_-保持最新做出贡献" class="toc-link">Git Upstream: 保持最新做出贡献</a></li><li class="toc-item toc-level-2">
                <a href="#publish-with-git-fork" class="toc-link">Publish with git fork</a></li><li class="toc-item toc-level-2">
                <a href="#tip-of-the-day_-ahead_behind-number-in-the-promt" class="toc-link">Tip of the day: Ahead/Behind number in the promt</a></li><li class="toc-item toc-level-2">
                <a href="#内部结构" class="toc-link">内部结构</a></li><li class="toc-item toc-level-2">
                <a href="#getting-started-with-git-upstream" class="toc-link">Getting started with git upstream</a></li></ul></nav>
        </aside>
        <div class="post-content">
            <p>Fork 项目来进行自己的修改，可以让你轻松地整合自己的贡献，但是如果你没有将这些修改发回上游 - 也就是发回父亲仓库 – 你就有可能失去对他们的跟踪，这可能会导致你的版本库中出现不同的线路。为了确保所有贡献者都从同有个地方获取信息，你需要了解一些关于 git forking 与 git upstream 如何交互的原理。在这篇博客中，我将向你介绍基础知识，疑难杂症，甚至给你留下一个很酷的小技巧，让你走在曲线的前面。</p>
<h2 id="git-upstream_-保持最新做出贡献">Git Upstream: 保持最新做出贡献</h2>
<p>让我先详细介绍一下与上游仓库交互的常见设置和最基本的工作流程。</p>
<p>在一个标准的设置中，你通常有一个 origin 和一个 upstream remote - 后者是项目的守门人，或者你希望贡献的真实来源。</p>
<p>首先，缺人你已经为上游仓库设置了一个 remote, 并希望也设置了一个 origin:</p>
<pre><code class="language-bash">$ git remote -v
origin git@bitbucket.org:my-user/some-project.git (fetch)
origin git@bitbucket.org:my-user/some-project.git (push)
</code></pre>
<p>如果你没有上游，你可以很容易地用远程命令添加它。</p>
<pre><code class="language-bash">git remote add upstream git@bitbucket.org:some-gatekeeper-maintainer/some-project.git
</code></pre>
<p>检查 remote 添加成功:</p>
<pre><code class="language-bash">git remote -v
origin git@bitbucket.org:my-user/some-project.git (fetch)
origin git@bitbucket.org:my-user/some-project.git (push)
upstream git@bitbucket.org:some-gatekeeper-maintainer/some-project.git (fetch)
upstream git@bitbucket.org:some-gatekeeper-maintainer/some-project.git (push)
</code></pre>
<p>现在你可以用 fetch 收集上游仓库的最新变化。每次想要获得更新时，都要重复这个动作。</p>
<p>（如果项目的标签害没有合并到 master, 你还应该这样做：<code>git fetch upstream --tags</code>)</p>
<pre><code class="language-bash">git fetch upstream
</code></pre>
<p>一般来说，你要保持本地分支作为上游主分支的近似镜像，并在特性分支中执行任何工作，因为它们以后可能会成为 pull request .</p>
<p>在这一点，使用 merge 还是 rebase 并不重要，因为结果通常是一样的。让我们使用 merge：</p>
<pre><code class="language-bash">git checkout master
git merge upstream/master
</code></pre>
<p>当你想合上游的维护者分享一些工作时，你可以从 master 分支中创建一个特性分支，当你满意时，把它推送到你的远程仓库。</p>
<p>你也可以用 rebase 来代替，然后合并以确保上游有一套干净的提交（最好是一个）来评估。</p>
<pre><code class="language-bash">git checkout -b feature-x
#some work and some commits happen
#some time passes git fetch upstream
git rebase upstream/master
</code></pre>
<p>如果你需要把几个提交压成一个，你可以在这时使用厉害的 rebase 互动。</p>
<h2 id="publish-with-git-fork">Publish with git fork</h2>
<p>经过以上步骤后，通过简单的 push, 在远程 fork 中发布你的作品。</p>
<pre><code class="language-bash">git push origin feature-x
</code></pre>
<p>如果你在发布远程分支 feature-x 后，因为上游维护者的一些反馈而不得不更新它，就会出现一个小问题，你有几个选择：</p>
<p>创建一个新的分支，包含你和上游的更新将上游的更新合并到你的本地分支，并记录一个合并提交，这将使上游版本库混乱在上游跟新的基础上重新建立本地分支，然后强制推动到远程分支</p>
<pre><code class="language-bash">git push -f origin feature-x
</code></pre>
<p>我个人更倾向于尽量保持历史记录的干净，选择方案三，但不同的团队有不同的工作流程。注意：只有在使用你自己的 fork 时，你才能这样做，重写共享库和分支的历史是绝对不应该做的。重写共享库和分支的历史是你永远不应该改做的事情。</p>
<h2 id="tip-of-the-day_-ahead_behind-number-in-the-promt">Tip of the day: Ahead/Behind number in the promt</h2>
<p>fetch 之后，git status 会显示你比同步的远程分支提前或落后多少次提交。如果你能在你忠实的命令行提示符下看到这些信息，岂不是更好？我也是这么想的，所以我开始用我的 bash chopsticks 并制作了它。</p>
<p>下面是你配置好后，它在你的提示符上的样子：</p>
<pre><code class="language-bash">nick-macbook-air:~/dev/projects/stash[1|94]$
</code></pre>
<p>这就是你需要添加到你的.bashrc 或等价物中的东西，只是一个函数：</p>
<pre><code class="language-bash">function ahead_behind {
  curr_branch=$(git rev-parse --abbrev-ref HEAD);
  curr_remote=$(git config branch.$curr_branch.remote);
  curr_merge_branch=$(git config branch.$curr_branch.merge | cut -d / -f 3);
  git rev-list --left-right --count $curr_branch...$curr_remote/$curr_merge_branch | tr -s '\t' '|';
}
</code></pre>
<p>你可以用这个新函数 ahead_behind 来丰富你的 bash 提示，已达到想要的效果。我把着色的工作留给读者去做。</p>
<p>Sampl prompt:</p>
<pre><code class="language-bash">export PS1="\h:\w[\$(ahead_behind)]$"
</code></pre>
<h2 id="内部结构">内部结构</h2>
<p>对于那些喜欢细节和解释的人来说，这是如何工作的。</p>
<p>我们得到当前 HEAD 的符号名称，及当前分支。</p>
<pre><code class="language-bash">curr_branch=$(git rev-parse --abbrev-ref HEAD);
</code></pre>
<p>我们得到当前分支所指向的远程：</p>
<pre><code class="language-bash">curr_remote=$(git config branch.$curr_branch.remote);
</code></pre>
<p>我们得到了这个远程分支应该被合并到的分支上（通过一个廉价的 Unix 技巧来丢弃包括最后一个斜杠 [/] 在内的所有内容）。</p>
<pre><code class="language-bash">curr_merge_branch=$(git config branch.$curr_branch.merge | cut -d / -f 3);
</code></pre>
<p>现在我们有了我们需要的东西来手机我们领先和落后的提交次数</p>
<pre><code class="language-bash">git rev-list --left-right --count $curr_branch...$curr_remote/$curr_merge_branch | tr -s '\t' '|';
</code></pre>
<p>我们使用古老的 Unix tr 将 TAB 转换为分隔符 |.</p>
<h2 id="getting-started-with-git-upstream">Getting started with git upstream</h2>
<p>这就是 git upstream 的基本演练，– 如何设置 git upstream, 创建新分支，收集修改，用 git fork 发布，还有一个贴心的提示，这就是你的远程分支领先 / 落后于你多少次提交。</p>

        </div>
    </div>
    

    <footer class="post-footer">
        <div class="post-info">
            <p><strong>Storage ID:</strong> <code>QmemS7hUjRit3oQWKU5qv4FWkKnxjremuwdvev4TdRQJuR</code></p>
            
            <p><strong>IPFS Link:</strong> <a href="https:&#x2F;&#x2F;ipfs.io&#x2F;ipfs&#x2F;QmemS7hUjRit3oQWKU5qv4FWkKnxjremuwdvev4TdRQJuR" target="_blank">View on IPFS</a></p>
            
            <p><strong>Content Hash:</strong> <code>c0b5a84c72db7a07fee6ebe8448e7484522ff1bc0d43941e6796cec5587b55d5</code></p>
        </div>
        <nav class="post-nav">
            <a href="/archive.html">← Back to Archive</a>
        </nav>
    </footer>

    
    <!-- Related Posts -->
    <section class="related-posts">
        <h2>Related Posts</h2>
        <div class="related-posts-grid">
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;chanzhe.html">禅者的初心📒</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">1 min read</span>
                    
                </div>
                
                    <p class="excerpt">是智慧在追寻智慧。 初学者的心是开放的，而行家的心是收紧的。 我们的本心内含万物，它本自具足。 如果你的心是空的，它可以随时接受任何事物；它向所有的事物开放。初学者的心是开放的，而行家的心是收紧的。 分别心太重，是自我束缚。太过苛刻和贪婪，你的心便不会丰饶富足。而失去了本自具足的心，我们会失守所有的…</p>
                
                
            </article>
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;T.html">TingHu语录📒</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">4 min read</span>
                    
                </div>
                
                    <p class="excerpt">大多数人最后跑不赢比特币这句话我都不知道讲了多少次了(实际上最后很多人还亏钱)。 如果你指望我通过推荐你买小山寨跑赢比特币，那还是别关注我了，我没有办法给出我认为合理的建议。 现在说也许还早，但是大家可以记住这一条，年底筛选投资标的的时候， 2019-2021这轮牛市表现一般的老币，全部不作为目标，…</p>
                
                
            </article>
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;rust-raw-pointer.html">About Rust Raw Pointer</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">2 min read</span>
                    
                </div>
                
                    <p class="excerpt">在Rust中可以使用原生指针，原生指针是一种裸指针，不受Rust的安全性检查限制。 原生指针有两种类型： 和 ，分别是不可变和可变的原生指针。 Rust提供了一个函数可以获取类型的大小： 。 这里提供了一个简单的例子，展示了如何使用原生指针。 原生指针是一种裸指针，不受Rust的安全性检查限制，可以…</p>
                
                
            </article>
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;learn-ocaml-sources.html">学习Ocaml的资源</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">1 min read</span>
                    
                </div>
                
                    <p class="excerpt">Introduction to Objective Ocaml Objective Caml 简介。 OCaml from the Very Beginning 一本非常温和的教科书，推荐用于本课程。本书的 PDF 和 HTML 格式都是免费的。 A guided tour [ of OCaml ]…</p>
                
                
            </article>
            
            <article class="related-post-card">
                <h3><a href="&#x2F;kpgb&#x2F;posts&#x2F;rust-tips.html">About Rust tips</a></h3>
                <div class="post-meta">
                    <span class="date">2025-07-23</span>
                    
                    <span class="reading-time">7 min read</span>
                    
                </div>
                
                    <p class="excerpt">在 Rust 中，如果你想为你的 中的类型编写带有可选的 的测试，你可以使用 属性和 属性来做到这一点。 以下是一个例子： 在这个例子中， 只有在 被启用时才会被定义，同样， 测试也只有在 被启用时才会被运行。 要运行这个测试，你需要使用以下命令，其中 是你的 的名字： 这个命令会启用 特性并运行所…</p>
                
                
            </article>
            
        </div>
    </section>
    

    
    <!-- Giscus Comments -->
    <div class="comments">
        <h2>Comments</h2>
        <script src="https://giscus.app/client.js"
                data-repo="davirain-su&#x2F;kpgb"
                data-repo-id="R_kgDOPP4-yg"
                data-category="General"
                data-category-id="DIC_kwDOPP4-ys4CtTKw"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="preferred_color_scheme"
                data-lang="zh-CN"
                data-loading="lazy"
                crossorigin="anonymous"
                async>
        </script>
    </div>
    
</article>


<script>
// TOC active section highlighting
(function() {
    const tocLinks = document.querySelectorAll('.toc-link');
    const headings = document.querySelectorAll('.post-content h1[id], .post-content h2[id], .post-content h3[id], .post-content h4[id], .post-content h5[id], .post-content h6[id]');
    
    if (tocLinks.length === 0 || headings.length === 0) return;
    
    function updateActiveSection() {
        const scrollPosition = window.scrollY + 100; // Offset for better UX
        
        let activeHeading = null;
        for (const heading of headings) {
            if (heading.offsetTop <= scrollPosition) {
                activeHeading = heading;
            } else {
                break;
            }
        }
        
        if (activeHeading) {
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + activeHeading.id) {
                    link.classList.add('active');
                }
            });
        }
    }
    
    // Update on scroll
    let scrollTimer;
    window.addEventListener('scroll', () => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(updateActiveSection, 50);
    });
    
    // Initial update
    updateActiveSection();
})();
</script>


        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 Anonymous. Powered by IPFS & KPGB.</p>
            <p>A decentralized blog powered by IPFS</p>
        </div>
    </footer>
</body>
</html>